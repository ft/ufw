# Developer Documentation {#developerdocs}

## MakeMeHappy Orchestration {#develmmh}

The `mmh` build orchestration tool that uses some of `ufw`'s CMake modules to
perform its job. In other words, if you would like to use `mmh` for build
orchestration, you must depend on `ufw`. It is not required to link against any
of the `ufw` libraries, but some of the CMake modules are non-optional.


### MakeMeHappy Module Support {#ufwmmhmodule}

`mmh` has support for running modular software builds (see @ref mmhmodulebuilds
for details). For this to work, modules need to specify their features and
requirements. The file to perform this specification is `module.yaml`, which
needs to exist in a software module's root directory. `ufw` is such a module.
It is a also a leaf-node in dependency graphs (i.e. it does not have any
additional dependencies). Next to the `ufw` C library, the module specification
lists CMake modules, and toolchains, and extensions. See the `module.yaml` file
in the top-level of the `ufw` project for details.

As such, `ufw` can serve as a foundational piece for modularised software
builds. That is libraries, applications, as well as Zephyr applications.


### MakeMeHappy Module Builds {#mmhmodulebuilds}

`mmh` has two major modes of operation: Module mode, and System mode. In module
mode, `mmh` builds an ephemeral source-tree, into which is injects the sources
of all dependencies that a module specifies in its `module.yaml` file, as well
as the sources of the target module itself. With these sources in place `mmh`
generates a top-level `CMakeLists.txt` file that specifies a combined build of
all of them. With this ephemeral build-tree, `mmh` can run the common `cmake`
phases: `configure`, `build`, `test` (optional), `install` (optional).


#### Hello World {#mmhhelloworld}

`mmh` has many features to work with such module builds. To demonstrate this,
lets create a minimal example, similar to the usual `Hello World.` programs.
For this, create a new directory that contains three files: `CMakeLists.txt`,
`module.yaml`, and `main.c`. Here's the code for `main.c`:

```c
#include <stdio.h>
#include <stdlib.h>

#include <ufw/compiler.h>
#include <ufw/meta.h>

/* UNUSED is from "ufw/compiler.h", and marks things that exists to be
 * known to not be used. Many compilers warn about these otherwise. */
int
main(UNUSED int argc, UNUSED char *argv[])
{
    (void)printf("UFW Version: %d.%d.%d\n",
                 /* The version macros are from "ufw/meta.h". */
                 UFW_LIBRARY_MAJOR,
                 UFW_LIBRARY_MINOR,
                 UFW_LIBRARY_PATCH);
    return EXIT_SUCCESS;
}
```

For `module.yaml`, use this:

```yaml
# "name" and "dependencies" are mandatory.
name: hello-world

dependencies:
  - name: ufw
    revision: v6.0.1

# We also specify "toolchains", "buildconfigs" and "buildtools". This
# is done to limit the number of builds mmh will do by default. mmh
# normally wants to build a piece of code with as many combinations
# of targets, toolchains, buildconfigs, tools, etc. This reduces the
# number of combinations to one.
toolchains:
  - name: gnu
    architecture: native
    interface: posix

buildconfigs:
  - debug

buildtools:
  - ninja
```

And for `CMakeLists.txt`:

```cmake
# The usual CMake boilerplate:
cmake_minimum_required(VERSION 3.20.0)
project(hello-world C)

# This is for MakeStrictCompilerC().
include(InitialiseToolchain)

# Build the hello-world program from "main.c" and "ufw", with strict
# C compiler warnings enabled.
add_executable(hello-world main.c)
target_link_libraries(hello-world PRIVATE ufw)
MakeStrictCompilerC(hello-world)
```

This is much simpler than the boilerplate shown in @ref cmakebuildsys. This is
possible, because all the required boilerplate will be generated by `mmh` in
the top-level `CMakeLists.txt` file of the ephemeral source-tree.

With this in place, it is possible to build the little project:

```
% mmh --log-to-file --show-phases
Logging to: build.log
mmh/preparation: load-dependencies
cmake/native/hello-world/gnu/debug/ninja: configure
cmake/native/hello-world/gnu/debug/ninja: compile
cmake/native/hello-world/gnu/debug/ninja: test
```

It is possible to investigate the generated `build.log` file using `mmh`'s
`result` command (`-q` quiets down `mmh` execution a little):

```
% mmh -q result build.log
Build Summary:

Checkpoint: module-initialisation
    Time     :   000:00.027
Checkpoint: load-dependencies
    Time     :   000:00.862
Checkpoint: generate-toplevel
    Time     :   000:00.004
----------------------------------------------------------------------------------------------------
                                Toolchain                 Architecture           Config    Buildtool
                                      gnu                       native            debug        ninja     Success
    Configure:   000:07.427     Success
        Build:   000:03.029     Success
    Testsuite:   000:00.264     Success
      Install:                      ---
    Time     :   000:10.721
Checkpoint: cleanup
    Time     :   000:00.016
Checkpoint: finish

Total runtime: 000:11.629

All 1 builds succeeded.
```

Or, if you are just interested in the overall result:

```
% mmh -q result -s build.log
All 1 builds succeeded.
```

It is also possible to scan the log-file for compiler incidents such as
warnings:

```
% mmh -q result -r build.log
No compiler incidents found.
```

Our build is clean, which is nice. To see this working, it is possible to
remove `UNUSED` from the `argc` argument of `main()` in `main.c`. With that:

```
% mmh -q result -r build.log
Incidents for /tmp/mmh-hello-world-a9b7c53d4d40cf079d88c1d9506a818201a32dbf-root/code-under-test/main.c:
  8:10: warning: unused parameter ‘argc’ [-Wunused-parameter]

Found 1 compiler incident(s).
```

These incidents are deduplicated, which is extremely important when many more
build instances are active. This also demonstrates, that in module builds,
`mmh` on its own will build the whole project in a temporary build tree. This
build-tree is even removed after build. This makes running the program we just
built a little difficult. This removal can be disabled by using `--preserve`
when building. Normally, during development, it is better to just specify a
build directory using `--directory` (or `-d` for short). In that case the
directory is not removed. Let's use `b` for instance, and use some more
advanced `mmh` commands. Normally when `mmh` is called without a command, in
module builds it will use `build` as its default. `build` is basically a
combination of `prepare` and `run`. The `prepare` command performs resolving
dependencies and generating the ephemeral build tree. `run` then runs the
`cmake` phases we mentioned earlier. Here is what happens (trimmed output):

```
% mmh -d b prepare
Starting up using 'prepare' command
…
Loading module description: module.yaml
…
Setting up build-directory: b
Creating instance config: b/MakeMeHappy.yaml
    Populating build-directory: build
    Populating build-directory: deps
    Linking code-under-test: /tmp/hw
Changing into build-directory: b
Phase: mmh/preparation: load-dependencies
Fetching revision v6.0.1 of module ufw
Running command: ['git', '-c', 'advice.detachedHead=false', 'clone', '--quiet', 'https://github.com/ft/ufw.git', 'deps/ufw']
Running command: ['git', '-c', 'advice.detachedHead=false', 'checkout', '--quiet', 'v6.0.1']
Inspecting Dependency Version Tree...
Inspecting Dependency Version Tree... done.
Updating MakeMeHappy.yaml with CMake information
```

The build tree in "b" will look like this (this demonstration was done in
`/tmp/hw`):

```
% tree -L 3 .
.
├── b
│   ├── build
│   ├── CMakeLists.txt
│   ├── code-under-test -> /tmp/hw
│   ├── deps
│   │   └── ufw
│   └── MakeMeHappy.yaml
├── CMakeLists.txt
├── main.c
└── module.yaml
```

Feel free to investigate the contents of `CMakeLists.txt` and
`MakeMeHappy.yaml` in there. Now we can ask `mmh` what build-instances it can
generate for this build-tree:

```
% mmh -q -d b list-instances
cmake/native/hello-world/gnu/debug/ninja
```

It can only find one possible instance, which is due to the additional setup we
did in `module.yaml` earlier. Feel free to experiement with that, to see if you
can extend the number of build instances here.

Now it is possible to run the build instances:

```
% mmh -d b -l -P run
Logging to: b.log
mmh/preparation: load-dependencies
cmake/native/hello-world/gnu/debug/ninja: configure
cmake/native/hello-world/gnu/debug/ninja: compile
cmake/native/hello-world/gnu/debug/ninja: test
```

The build will actually be done in:

- `b/build/cmake/native/hello-world/gnu/debug/ninja`

This process can be repeated. Every time `run` is called, it will first clean
out that build directory to perform a completely clean build. If incremental
builds are desired, it is possible to run the build system inside of that
directory manually. It is just a little tedious to access this directory every
time. To simplify this, `mmh` has a `focus` command:

```
% mmh -q -d b focus cmake/native/hello-world/gnu/debug/ninja

Creating Focus for Build Instance:
  compile_commands.json -> b/build/cmake/native/hello-world/gnu/debug/ninja/compile_commands.json
  focus -> b/build/cmake/native/hello-world/gnu/debug/ninja
```

With these symlinks, it is possible to incrementally rerun the build like this:

```
% cd focus
% ninja
ninja: no work to do.
```

Also, while in there, lets run the program we just built:

```
% ./code-under-test/hello-world
UFW Version: 6.0.1
```

This is the expected output with the version of the `ufw` dependency that was
specified in `module.yaml`.


#### Tiny Portable Library {#mmhtinylib}

When building applications (like the little program in @ref mmhhelloworld, or
firmware applications in general), you usually need to limit the build to the
targets the application supports. Like the `posix/native` build we used earlier.

`mmh` is most powerful when used with portable libraries, so their codebases
can be exercised by as make toolchains, target, buildconfigs, and tools as
possible. To take a look at this, we will create another tiny example. First
our library code:

```c
#include <tiny.h>

int
times2(const int input)
{
    return input + input;
}
```

And a proper header for the library:

```c
#ifndef INT_TINYLIB_TINY_H
#define INT_TINYLIB_TINY_H

int times2(int input);

#endif /* INT_TINYLIB_TINY_H */
```

Every proper library needs a test-suite too. Let's add one using the @ref
ufwtapc API:

```c
#include <stdbool.h>
#include <stdlib.h>

#include <ufw/compiler.h>
#include <ufw/test/tap.h>

#include "tiny.h"

int
main(UNUSED int argc, UNUSED char *argv[])
{
    plan(5);
    ok(true, "true is true");
    ok((1 + 2) == 3, "math works");
    ok(times2(0) == 0, "2 times 0 is 0");
    okx(times2(23) == 46);
    okx(times2(-42) == -84);
    return EXIT_SUCCESS;
}
```

A really simple `module.yaml`:

```yaml
name: tiny-library

dependencies:
  - name: ufw
    revision: v6.0.1
```

To tie all things together, the library also needs a CMake specification:

```cmake
cmake_minimum_required (VERSION 3.20.0)

include(InitialiseToolchain)

add_library(tiny STATIC tiny.c)
target_link_libraries(tiny PUBLIC ufw)
target_include_directories(tiny PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
MakeStrictCompilerC(tiny)

# Also add a test suite using "ufw/test/tap.h".

include(UFWTest)
ufw_test_init()

ufw_test_program(t-tiny t-tiny.c)
target_link_libraries(t-tiny PRIVATE tiny ufw ufw-tap)
MakeStrictCompilerC(t-tiny)

ufw_add_test_runner(NAME  tinylib-tests
                    TESTS $<TARGET_FILE:t-tiny>)
```

All the usual `mmh` module build commands will work as expected. So let's
prepare the build:

```
% mmh -d b -l -P prepare
Logging to: b.log
mmh/preparation: load-dependencies
```

Because `module.yaml` does not limit the number of build instances, this will
build many more variants of the library. It mostly depends on the user's `mmh`
configuration. For the author, that currently means:

```
% mmh -q -d b list-instances | wc -l
64
```

These are possible combinations of:

```
% mmh -q --query architectures
c28x-float cortex-m3 cortex-m4-hardfp mips native

% mmh -q --query buildconfigs
debug minsizerel release relwithdebinfo

% mmh -q --query buildtools
make ninja

% mmh -q --query toolchains
arm-zephyr-eabi clang gnu gnu-arm-none-eabi mips-linux-gnu ti-arm ti-c2000
```

As per usual, we can inspect the build results:

```
% mmh -q result -s b.log
All 64 builds succeeded.
% mmh -q result -r b.log
No compiler incidents found.
```

And because the `tiny` library uses the API of `UFWTest` to specify its test
suite, the test-suite is automatically getting run for the `native` builds, as
well as for all architectures that are are contained in @ref ufwcustomtargets.
This includes `cortex-m3` and `mips`. The cross-built test-suites for these
targets are automatically run through `QEMU`. And our `tiny` little library
passed all those.


#### Zephyr Applications as Module Builds {#mmhzephyrapp}

With Zephyr applications, `mmh` needs to generate the ephemeral source-tree
with a couple of more parameters. For this the `type: zephyr` parameter must be
used in `module.yaml`. For instance:

```yaml
name: zephyr-sample-blinky
type: zephyr

dependencies:
  - name: zephyr-kernel
    revision: v3.7.0
  - name: ufw
    revision: v5.6.0
  # If revisions for zephyr-* modules are not specified mmh will
  # try to resolve them from the kernel's west.yml file.
  - name: zephyr-arm-cmsis
  - name: zephyr-hal-stm32
  - name: zephyr-picolibc

zephyr-aliases:
  stm32h747i_disco_m7: stm32h747i_disco/stm32h747xx/m7

targets:
  - boards:
      - stm32h747i_disco_m7
      - nucleo_f767zi
      - nucleo_l476rg
    toolchains:
      - name: gnuarmemb
        path: /usr
    modules:
      - zephyr-arm-cmsis
      - zephyr-hal-stm32
      - zephyr-picolibc

buildconfigs:
  - release
  - debug

buildtools:
  - ninja
```

The full example, where this is taken from
[zephyr-sample-blinky](https://gitlab.com/ft/zephyr-sample-blinky), which is
the `blinky` sample from Zephyr itself, formed into a standalone project, for
`mmh` demonstration purpuses. Check it out for details.

All `mmh` module features work with zephyr builds. Examples:

```
% mmh -d b -l -P
Logging to: b.log
mmh/preparation: load-dependencies
zephyr/nucleo_f767zi/zephyr-sample-blinky/gnuarmemb/debug/ninja: configure
zephyr/nucleo_f767zi/zephyr-sample-blinky/gnuarmemb/debug/ninja: compile
zephyr/nucleo_f767zi/zephyr-sample-blinky/gnuarmemb/release/ninja: configure
zephyr/nucleo_f767zi/zephyr-sample-blinky/gnuarmemb/release/ninja: compile
zephyr/nucleo_l476rg/zephyr-sample-blinky/gnuarmemb/debug/ninja: configure
zephyr/nucleo_l476rg/zephyr-sample-blinky/gnuarmemb/debug/ninja: compile
zephyr/nucleo_l476rg/zephyr-sample-blinky/gnuarmemb/release/ninja: configure
zephyr/nucleo_l476rg/zephyr-sample-blinky/gnuarmemb/release/ninja: compile
zephyr/stm32h747i_disco_m7/zephyr-sample-blinky/gnuarmemb/debug/ninja: configure
zephyr/stm32h747i_disco_m7/zephyr-sample-blinky/gnuarmemb/debug/ninja: compile
zephyr/stm32h747i_disco_m7/zephyr-sample-blinky/gnuarmemb/release/ninja: configure
zephyr/stm32h747i_disco_m7/zephyr-sample-blinky/gnuarmemb/release/ninja: compile

% mmh -q -d b result -s b.log
All 6 builds succeeded.

% mmh -q -d b result -r b.log
No compiler incidents found.
```


### MakeMeHappy System Builds {#mmhsystembuilds}

System builds differ slightly from module builds. Instead of asking `mmh` to
provide a system's dependencies automatically, in system builds this
responsibility falls to the user — `mmh` fetches no code at all. Since systems
builds are a little different in behaviour, almost all their functionality is
contained in the `system` command of `mmh`. Still, when called without a
command, `mmh` automatically defaults to `system build` if it finds a
`system.yaml` file in the current working directory. This file specifies what
builds are intended to be carried out for a system.

A minimal example can by found in `test/module` of the `ufw` library. A more
complex example can be found in the `firmware` subdirectory of the
[chip-remote](https://github.com/ft/chip-remote) project.


## Fuzz-Testing for ufw {#develfuzz}

### Introduction

It is possible to  run fuzzers on parts of ufw. The fuzzer  used by the project
is `AFL++`, which needs to be installed as a prerequisite. For details see:

- https://aflplus.plus
- https://github.com/AFLplusplus/AFLplusplus

AFL++ comes with a program called `afl-fuzz`, which can be used to feed
arbitrary data into a program's stdin in order to exercise it. The ufw library
has programs using the library that can be used with this scheme.

The fuzzing integration is implemented in the `fuzz` sub-directory of the
project. The following assumes the user is in this directory. The "run" program
in this directory helps with using `AFL++`.


### Initialisation

```
./run init
```

This compiles  ufw in native mode,  with the compiler being  set to `afl-clang`
into a directory called `build-afl`.  All instrumented example programs will be
located in and be run from this build directory tree.

It is possible to adjust `AFL++` installation specifics using these options:

```
  -A           AFL++ source directory
```

This allows to use `AFL++` from its source directory instead of from a
system-wide installation.

```
  -c COMPILER  Set compiler to COMPILER instead of "afl-clang".
  -r RUNNER    Set fuzzing runner to RUNNER instead of "afl-fuzz".
```

Based on these options, two  files `afl-compiler` and `alf-runner` are created.
The `run` script will use these to invoke the associated functionality.

For more control, you can also ask "init" to do the minimal amount of work:

```
  -m           Only initialise afl-compiler and afl-runner
```

After that the following can be used to setup the `build-afl` tree:

```
./run configure
```

And finally the `build` subcommand can be used to actually build ufw inside of
the `build-afl` sub-directory:

```
./run build
```

This command can also be used to re-run the compilation process in case the
library's code was changed.

When the `-m` option is not used with `init`, the sub-command runs the
`configure` and `build` steps automatically.


### Running Programs

```
./run fuzzer SUB-DIRECTORY
```

Each runnable program is associated with a sub-directory inside of `fuzz`. The
name of these directories matches the name of the example programs in `ufw`'s
`example` sub-directory.

Examples that do not have such a directory are not supported to be fuzzed.

And additional argumants passed to the sub-command after the `SUB-DIRECTORY`
parameter are passed to the afl-runner (`afl-fuzz`) program.


### Cleaning Up

```
./run clean
```

This cleans up build artefacts from other `run` invocations. Use the `-a`
option to `clean` to remove fuzzer outputs as well.


### Full Example

Here is a full example, which assumes that `AFL++` is installed in
`~/src/AFLplusplus`:

```
./run init -A ~/src/AFLplusplus
./run fuzzer ex-regp-parse-frame
```

The final command will run `afl-fuzz` with an instrumented version of
`examples/ex-regp-parse-frame.c` with state from `fuzz/ex-regp-parse-frame`. To
exit the program, press `CTRL-C`.
