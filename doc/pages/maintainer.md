# Maintainer Documentation

## Maintainer Tooling

The library offers a number of tools aimed for use by the maintainer mostly.
There is nothing wrong with anyone using them, though. This is a rundown of
these tools.

### Special Purpose Builds

#### apidoc-build.sh

```
% ./tools/apidoc-build.sh -h

This is a helper that runs ufw's documentation generation process. The
main target is HTML. For best experience, it should be viewed inside
of a browser that is capable of running JavaScript.

usage:   ./tools/apidoc-build.sh [OPTION(s)...]

Available options:

  -h       Display this help text
  -r       Only create $bd if it does not exist yet
  -e       Enable WARN_AS_ERROR in doxygen execution
  -o DIR   Use DIR instead of $bd for building documentation

Use -r after initial builds for much increased generation speeds.
```

#### compat-build.sh

When doing releases, it is important to keep track of ABI (though with `ufw`
almost always being compiled alongside its users, this is less important) and
API (this is extremely important) changes. Extending APIs requires a minor
release. Breaking APIs requires a major release. This program (using
[abi-dumper](https://github.com/lvc/abi-dumper) and
[abi-compliance-checker](https://lvc.github.io/abi-compliance-checker)) creates
a report about these changes.

```
% ./tools/compat-build.sh -h

This program 


```


#### coverage-build.sh

The library has support for generating coverage data. This can be enabled when
running the project's test-suite. This program does that, and then uses
[govr](https://gcovr.com) to produce an HTML report. This report should be
reviewed regularly and test coverage should be improved if possible.


### Miscellaneous Checks

#### clang-tidy.sh

```
% ./tools/clang-tidy.sh -h

This tool helps running clang-tidy for ufw. Because it tries to cover
the Zephyr part of the library as well, it requires a working Zephyr
build tree to work. For this the tool reuses the build-tree of the
Zephyr module buile test in "test/module". Without running it, this
program will not work.

usage:   ./tools/clang-tidy.sh [OPTION(s)...]

Available options:

  -h       Display this help text
  -c       Enable colouration of clang-tidy output
  -f       Enable automatic fix-application in clang-tidy
  -o FILE  Use FILE to log clang-tidy output into. By default
           output is delivered to stdout.
  -L       Enable output of a coloured label before execution

The output of the program is viable for "M-x compile" in emacs.
```

#### clang-analyzer.sh

```
% ./tools/clang-analyzer.sh -h

This is a helper for clang's static analyzer on ufw's codebase.

usage:   ./tools/clang-tidy.sh [OPTION(s)...]

Available options:

  -h       Display this help text
  -r       Only create $bd if it does not exist yet
  -o DIR   Use DIR instead of $bd for running the analyzer

It is recommended to use "-r" for subsequent runs, to cut down on
execution time. By default the whole process always runs completely
fresh.
```

#### check-changes.sh

This tests if the `CHANGES` file is consistent and fit for release. All release
header in this file have to be correct for this to pass.


#### check-copyright.sh

This programs checks the copyright headers in most files of the codebase. The
notice has to exist, and the start and and years have to be consistent with
what was recorded in git. The program can even add and update such notices.

#### check-meta-h.sh

This is a test for the consistency of `ufw/meta.h`,
such that it is ready for release.

### GNU Guile Wrapper: run

Some of the tooling in `tools/` if written in GNU Guile Scheme. This is a
wrapper for `guile`, that includes `scheme/` in the module search path, which
these tools may be using. Any `*.scm` tool should be run through this wrapper.

#### make-binary-format.scm

The `ufw/binary-format.h` file is fully
generated. This is the program that generates it. Example use:

```
% ./tools/run tools/make-binary-format.scm > include/ufw/binary-format.h
```

#### tools/make-register-macros.scm

Some of `ufw/register-table.h` file is generated by this program. The output of
it belongs somewhere after `Register Specification Front-Ends`. Only do this if
you know what you are doing.

### Other Tooling

#### quick.yaml

This is a configuration file for MakeMeHappy (`mmh`), that limits the number of
build instances it will run. This is useful to get an idea if changes to the
codebase have a chance of working without having to run the full set of release
builds.

#### generate-diffstat.sh

This is a little helper to generate `diff-stat` usable for updating the
`CHANGES` file.

### release-tests.sh

Finally, this programs runs all sorts of tests and creates a report about any
issues it encounters. If this tool is happy, a release can probably be pushed
to public `git` repositories.


## Release Process

### Concepts

The library is regularly released. There is currently no public roadmap, that
details the way in which releases are going to be made. At the moment, any
change is technically possible, and releases types (major/minor/patch) will be
done as required. This does not mean, that compatibility will be broken without
any concern. In fact, API discipline and thus keeping compatibility is one of
the qualities of the library. Breaking it usually will require deprecation
periods and the like. A release of `ufw` is a commit that has a signed `vX.Y.Z`
tags connected to it. Pre-Releases (`vX.Y.Z-preN`) and release-candidates
(`vX.Y.Z-rcN`) are allowed, but do not constitude a release.

- When release candidates are tagged, `master` should not changes anything
  about the featureset of the library anymore until a release is finally
  tagged.
- Pre-Releases are snapshots. The kind of release that is to follow
  (major/minor/patch) should be established at this point, but changes being
  made to `master` are much more open than with release candidates.

### Checklist

With that being said, tasks for the maintainer before release:

`include/ufw/meta.h` must be updated. It reflects the version of the library,
and therefore the major/minor/patch macros defined in it must match the
release-tag in `git`.

A complete release-build must run without failure. This should exercise the
codebase with a large number of builds. This currently includes the following
toolchains:

- `gnu`: A native build using the `gnu` toolchain file. This uses the host's
  `gcc`.
- `clang`: This is similar to `gnu`, but using the host's `clang` compiler.
  Note that this is the `clang` compiler without a version suffix.
- `gnu-arm-none-eabi`: This is the embedded ARM Cortex toolchain. This builds
  with `cortex-m3` and `cortex-m4-hardfp` architectures. With the former, the
  test-suite is run through QEMU as well.
- `arm-zephyr-eabi`: This is the embedded ARM Cortex toolchain from the Zephyr
  project. It is extremely similar to the `gnu-arm-none-eabi` toolchain. This
  builds with the `cortex-m3` architecture and run the test-suite through QEMU.
- `mips-linux-gnu`: With the `mips` architectures, we exercise the codebase for
  big-endian plattforms. The test-suite runs through QEMU as well.
- `ti-arm`: This is Texas Instruments' legacy ARM toolchain. It will show some
  warnings that other toolchains do not.
- `ti-c2000`: Texas Instruments has a number of DSP plattforms, C2000 is one of
  those. One quirk about this platform is that a byte on it is 16 bits wide.
  Keeping compatibility with plattforms like this is difficult.

This full release build must be completely warning free.

The API documentation must build correctly.

Since `ufw` can be a Zephyr module, a build using `ufw` in a Zephyr application
build must by performed. This is available in `test/module`.

The test-suite for `vcs-integration` must pass.

A test coverage report must be reviewed. Fully untested new code is a smell.
And release-to-release, coverage should improve.

ABI/API compatibility must be reviewed. The release type being done must match
the result of such a report.

The copyright notices must be up-to-date. This is most important to review with
the first release of a year.

`CHANGES` must be updated, keeping consistence with previous entries in the
file. The release date must match the according release-tag in `git`. The
previous release mentioned in the entry must match the release name of the
previous entry. To update the `Diffstat` section, you can use the output of the
utility in `tools/generate-diffstat.sh`.


When every check is performed and passes adequately, a release can be carried
out.

- A signed `git` tag reflecting the release must be created.
- Before pushing the result, the tests should be re-run. Too often tiny issues
  snug in.
- If everything is still looking good, pushing to public repositories is okay.
  Though it is okay to perform additional tests, like upgrading other projects
  that use `ufw` and see what happens with those.

The next release-cycle can begin.

Most of the release tests mentioned in here are automated by
`tools/release-tests.sh`. Use it instead of doing things manually! Indeed, use
`./tools/release-tests.sh help` to see how to use the script. For a quick check
with only the minimal set of important toolchains, `quick` is fine. When
preparing a release, the first test (possibly untagged) may be run in `reduced`
mode. The final test before publishing a release must run everything using the
`run` subcommand.
