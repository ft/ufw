/*
 * Copyright (c) 2019-2024 ufw workers, All rights reserved.
 *
 * Terms for redistribution and use can be found in LICENCE.
 *
 * This file is generated by ‘tools/make-binary-format.scm’.
 */

/**
 * @file binary-format.h
 * @brief Binary format conversion API
 *
 * This module implements a number of functions that revolve around reading and
 * writing values to/from raw memory. This is done in three octet-orders
 * (endianness): Native, big and little; where native endianness is one of the
 * other two.
 *
 * The API follows a naming scheme:
 *
 *     bf_[OPERATION]_[TYPEMNEMONIC][WIDTH][ORDER](...)
 *
 * Where OPERATION is either `ref` or `set`. The `ref` (reference) operation
 * extracts a datum from raw memory; and the `set` operation transfers a datum
 * into raw memory.
 *
 * Where TYPEMNEMONIC is either `u` or `s` or `f` for unsigned integers, signed
 * integers and floating point values respectively; and
 *
 * Where WIDTH is a width designation in bits. Integer operations support 16,
 * 32 and 64 bits; on machines where a byte is an octet, integer operations also
 * support 24, 40, 48 and 56 bit word widths. Floating point values support 32
 * and 64 bits.
 *
 * Where ORDER is either `n` or `b` or `l` for native, big or little endianness
 * respectively.
 *
 * To put a 32-bit floating point value into memory, in big-endian octet order:
 *
 * @code
 *     uint8_t memory[128];
 *     // ...
 *     bf_set_f32b(memory, 123.f);
 * @endcode
 *
 * Similarly, to reference a 32-bit floating point value in memory, in big 
 * endian octet order:
 *
 * @code
 *     float foo = bf_ref_f32b(memory);
 * @endcode
 *
 * In addition to these `ref` and `set` operations, the module also implements
 * simple range-check functions, on systems that support the 24, 40, 48 and 56
 * bit wide operations. When putting a datum into raw memory, no range checks
 * are performed implicitly. If data such validation is required, use one of
 * the functions that follow this API scheme:
 *
 *     bool bf_inrange_[TYPEMNEMONIC][WIDTH](const TYPE value);
 *
 * These functions return a boolean value indicating whether or not the provided
 * value is valid for the indicated type and word width. The TYPEMNEMONIC part
 * is either `u` for unsigned integers or `s` for signed integers. The WIDTH
 * part is one of the aforementioned word widths.
 *
 * For example, to test if a value is a signed 40 bit integer use:
 *
 * @code
 *     if (bf_inrange_s40(-12345)) {
 *         bf_set_s40b(memory, -12345);
 *     }
 * @endcode
 *
 * Portability notes:
 *
 * The module supports (and was tested with) little and big endian machines.
 *
 * The size of a byte is the smallest addressable word in memory on a given
 * machine. In particular, the colloquially used notion of a byte being eight
 * bits of memory, is not correct in general. A more precise name for eight
 * bits of memory is an octet. The POSIX specification requires a byte to be
 * an octet, but the C language notably does not. This module supports systems
 * that use 8 bit and 16 bit bytes (other byte sizes are not supported and
 * will cause a build-failure). However, the parts of the API that support
 * partial word-sizes (24, 40, 48, and 56) are only supported on 8-bit
 * addressable machines.
 *
 * Integer encoding across architectures is pretty portable these days. Two's
 * complement is used universally in all modern architectures. There are things
 * like IBM main frames that use BCD for example, and there will be other
 * examples, that could be brought up here. If your system does not use two's
 * complement, signed-integer semantics will not work as intended.
 *
 * Floating point number encodings are less portable, but IEEE754 is pretty
 * common. This module implements all accesses on the architecture's native
 * representation. If your system does not use IEEE754 floating point
 * encoding, floating point semantics will not work as intended.
 */

#ifndef INC_UFW_BINARY_FORMAT_H
#define INC_UFW_BINARY_FORMAT_H

#include <stdbool.h>
#include <stdint.h>

#include <ufw/bit-operations.h>
#include <ufw/toolchain.h>

#ifdef __cplusplus
#ifndef CXX_ALLOW_TYPE_PUNNING
#warning "binary-format uses type punning, which is undefined behaviour in C++!"
#warning "Your toolchain may allow it as an extension, but be advised!"
#warning "To disable this warning, define the CXX_ALLOW_TYPE_PUNNING macro."
#endif /* CXX_ALLOW_TYPE_PUNNING */
#endif /* __cplusplus */

#if !(defined(SYSTEM_ENDIANNESS_BIG)) && !(defined(SYSTEM_ENDIANNESS_LITTLE))
#error "System octet-order is not indicated! Cannot use binary-format.h for that reason!"
#endif /* !(defined(SYSTEM_ENDIANNESS_*)) */

#if !(UFW_BITS_PER_BYTE == 8 || UFW_BITS_PER_BYTE == 16)
#error "System byte-size is unsupported! Cannot use binary-format.h for that reason!"
#endif /* Unsupported Byte Size */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

union bf_convert16 {
    uint16_t u16;
    int16_t s16;
};

union bf_convert32 {
    uint32_t u32;
    int32_t s32;
    float f32;
};

union bf_convert64 {
    uint64_t u64;
    int64_t s64;
    double f64;
};

/**
 * Byte-swap 16 bit value
 *
 * Turn `0x1234` into `0x3412`.
 *
 * @param  value   The value to transform
 *
 * @return The byte-swapped value.
 * @sideeffects None.
 */
static inline uint16_t
bf_swap16(const uint16_t value)
{
#if defined(HAVE_COMPILER_BUILTIN_BSWAP16) && defined(UFW_USE_BUILTIN_SWAP)
    return __builtin_bswap16(value);
#else
    return ( ((value & 0xff00u) >> 8u)
           | ((value & 0x00ffu) << 8u));
#endif /* HAVE_COMPILER_BUILTIN_BSWAP16 */
}

/**
 * Byte-swap 24 bit value
 *
 * Turn `0x123456` into `0x563412`.
 *
 * @param  value   The value to transform
 *
 * @return The byte-swapped value.
 * @sideeffects None.
 */
static inline uint32_t
bf_swap24(const uint32_t value)
{
    return ( ((value & 0xff0000ul) >> 16u)
           | ((value & 0x00ff00ul))
           | ((value & 0x0000fful) << 16u));
}

/**
 * Byte-swap 32 bit value
 *
 * Turn `0x12345678` into `0x78563412`.
 *
 * @param  value   The value to transform
 *
 * @return The byte-swapped value.
 * @sideeffects None.
 */
static inline uint32_t
bf_swap32(const uint32_t value)
{
#if defined(HAVE_COMPILER_BUILTIN_BSWAP32) && defined(UFW_USE_BUILTIN_SWAP)
    return __builtin_bswap32(value);
#else
    return ( ((value & 0xff000000ul) >> 24u)
           | ((value & 0x00ff0000ul) >>  8u)
           | ((value & 0x0000ff00ul) <<  8u)
           | ((value & 0x000000fful) << 24u));
#endif /* HAVE_COMPILER_BUILTIN_BSWAP32 */
}

/**
 * Byte-swap 40 bit value
 *
 * Turn `0x1234567890` into `0x9078563412`.
 *
 * @param  value   The value to transform
 *
 * @return The byte-swapped value.
 * @sideeffects None.
 */
static inline uint64_t
bf_swap40(const uint64_t value)
{
    return ( ((value & 0xff00000000ull) >> 32u)
           | ((value & 0x00ff000000ull) >> 16u)
           | ((value & 0x0000ff0000ull))
           | ((value & 0x000000ff00ull) << 16u)
           | ((value & 0x00000000ffull) << 32u));
}

/**
 * Byte-swap 48 bit value
 *
 * Turn `0x1234567890ab` into `0xab9078563412`.
 *
 * @param  value   The value to transform
 *
 * @return The byte-swapped value.
 * @sideeffects None.
 */
static inline uint64_t
bf_swap48(const uint64_t value)
{
    return ( ((value & 0xff0000000000ull) >> 40u)
           | ((value & 0x00ff00000000ull) >> 24u)
           | ((value & 0x0000ff000000ull) >>  8u)
           | ((value & 0x000000ff0000ull) <<  8u)
           | ((value & 0x00000000ff00ull) << 24u)
           | ((value & 0x0000000000ffull) << 40u));
}

/**
 * Byte-swap 56 bit value
 *
 * Turn `0x1234567890abcd` into `0xcdab9078563412`.
 *
 * @param  value   The value to transform
 *
 * @return The byte-swapped value.
 * @sideeffects None.
 */
static inline uint64_t
bf_swap56(const uint64_t value)
{
    return ( ((value & 0xff000000000000ull) >> 48u)
           | ((value & 0x00ff0000000000ull) >> 32u)
           | ((value & 0x0000ff00000000ull) >> 16u)
           | ((value & 0x000000ff000000ull))
           | ((value & 0x00000000ff0000ull) << 16u)
           | ((value & 0x0000000000ff00ull) << 32u)
           | ((value & 0x000000000000ffull) << 48u));
}

/**
 * Byte-swap 64 bit value
 *
 * Turn `0x1234567890abcdef` into `0xefcdab9078563412`.
 *
 * @param  value   The value to transform
 *
 * @return The byte-swapped value.
 * @sideeffects None.
 */
static inline uint64_t
bf_swap64(const uint64_t value)
{
#if defined(HAVE_COMPILER_BUILTIN_BSWAP64) && defined(UFW_USE_BUILTIN_SWAP)
    return __builtin_bswap64(value);
#else
    return ( ((value & 0xff00000000000000ull) >> 56u)
           | ((value & 0x00ff000000000000ull) >> 40u)
           | ((value & 0x0000ff0000000000ull) >> 24u)
           | ((value & 0x000000ff00000000ull) >>  8u)
           | ((value & 0x00000000ff000000ull) <<  8u)
           | ((value & 0x0000000000ff0000ull) << 24u)
           | ((value & 0x000000000000ff00ull) << 40u)
           | ((value & 0x00000000000000ffull) << 56u));
#endif /* HAVE_COMPILER_BUILTIN_BSWAP64 */
}

/**
 * Read 16-bit value from memory in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint16_t datum read from 2 octets from memory pointed to by
 *         ptr in native octet order.
 * @sideeffects None.
 */
static inline uint16_t
bf_ref_u16n(const void *ptr)
{
    uint16_t buffer = 0u;
    const unsigned char *src = ptr;
    unsigned char *dst = (unsigned char*)&buffer;
#if UFW_BITS_PER_BYTE == 8
    dst[0u] = src[0u];
    dst[1u] = src[1u];
#endif /* UFW_BITS_PER_BYTE == 8 */
#if UFW_BITS_PER_BYTE == 16
    dst[0u] = src[0u];
#endif /* UFW_BITS_PER_BYTE == 16 */
    return buffer;
}

/**
 * Read 24-bit value from memory in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint32_t datum read from 3 octets from memory pointed to by
 *         ptr in native octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint32_t
bf_ref_u24n(const void *ptr)
{
    uint32_t buffer = 0ul;
    const unsigned char *src = ptr;
    unsigned char *dst = (unsigned char*)&buffer;
#if defined(SYSTEM_ENDIANNESS_BIG)
    dst[1u] = src[0u];
    dst[2u] = src[1u];
    dst[3u] = src[2u];
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
    return buffer;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 32-bit value from memory in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint32_t datum read from 4 octets from memory pointed to by
 *         ptr in native octet order.
 * @sideeffects None.
 */
static inline uint32_t
bf_ref_u32n(const void *ptr)
{
    uint32_t buffer = 0ul;
    const unsigned char *src = ptr;
    unsigned char *dst = (unsigned char*)&buffer;
#if UFW_BITS_PER_BYTE == 8
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
#endif /* UFW_BITS_PER_BYTE == 8 */
#if UFW_BITS_PER_BYTE == 16
    dst[0u] = src[0u];
    dst[1u] = src[1u];
#endif /* UFW_BITS_PER_BYTE == 16 */
    return buffer;
}

/**
 * Read 40-bit value from memory in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 5 octets from memory pointed to by
 *         ptr in native octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint64_t
bf_ref_u40n(const void *ptr)
{
    uint64_t buffer = 0ull;
    const unsigned char *src = ptr;
    unsigned char *dst = (unsigned char*)&buffer;
#if defined(SYSTEM_ENDIANNESS_BIG)
    dst[3u] = src[0u];
    dst[4u] = src[1u];
    dst[5u] = src[2u];
    dst[6u] = src[3u];
    dst[7u] = src[4u];
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
    dst[4u] = src[4u];
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
    return buffer;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 48-bit value from memory in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 6 octets from memory pointed to by
 *         ptr in native octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint64_t
bf_ref_u48n(const void *ptr)
{
    uint64_t buffer = 0ull;
    const unsigned char *src = ptr;
    unsigned char *dst = (unsigned char*)&buffer;
#if defined(SYSTEM_ENDIANNESS_BIG)
    dst[2u] = src[0u];
    dst[3u] = src[1u];
    dst[4u] = src[2u];
    dst[5u] = src[3u];
    dst[6u] = src[4u];
    dst[7u] = src[5u];
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
    dst[4u] = src[4u];
    dst[5u] = src[5u];
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
    return buffer;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 56-bit value from memory in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 7 octets from memory pointed to by
 *         ptr in native octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint64_t
bf_ref_u56n(const void *ptr)
{
    uint64_t buffer = 0ull;
    const unsigned char *src = ptr;
    unsigned char *dst = (unsigned char*)&buffer;
#if defined(SYSTEM_ENDIANNESS_BIG)
    dst[1u] = src[0u];
    dst[2u] = src[1u];
    dst[3u] = src[2u];
    dst[4u] = src[3u];
    dst[5u] = src[4u];
    dst[6u] = src[5u];
    dst[7u] = src[6u];
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
    dst[4u] = src[4u];
    dst[5u] = src[5u];
    dst[6u] = src[6u];
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
    return buffer;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 64-bit value from memory in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 8 octets from memory pointed to by
 *         ptr in native octet order.
 * @sideeffects None.
 */
static inline uint64_t
bf_ref_u64n(const void *ptr)
{
    uint64_t buffer = 0ull;
    const unsigned char *src = ptr;
    unsigned char *dst = (unsigned char*)&buffer;
#if UFW_BITS_PER_BYTE == 8
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
    dst[4u] = src[4u];
    dst[5u] = src[5u];
    dst[6u] = src[6u];
    dst[7u] = src[7u];
#endif /* UFW_BITS_PER_BYTE == 8 */
#if UFW_BITS_PER_BYTE == 16
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
#endif /* UFW_BITS_PER_BYTE == 16 */
    return buffer;
}

/**
 * Read 16-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint16_t datum read from 2 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
static inline uint16_t
bf_ref_u16b(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_ref_u16n(ptr);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_swap16(bf_ref_u16n(ptr));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Read 24-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint32_t datum read from 3 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint32_t
bf_ref_u24b(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_ref_u24n(ptr);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_swap24(bf_ref_u24n(ptr));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 32-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint32_t datum read from 4 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
static inline uint32_t
bf_ref_u32b(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_ref_u32n(ptr);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_swap32(bf_ref_u32n(ptr));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Read 40-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 5 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint64_t
bf_ref_u40b(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_ref_u40n(ptr);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_swap40(bf_ref_u40n(ptr));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 48-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 6 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint64_t
bf_ref_u48b(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_ref_u48n(ptr);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_swap48(bf_ref_u48n(ptr));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 56-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 7 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint64_t
bf_ref_u56b(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_ref_u56n(ptr);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_swap56(bf_ref_u56n(ptr));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 64-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 8 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
static inline uint64_t
bf_ref_u64b(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_ref_u64n(ptr);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_swap64(bf_ref_u64n(ptr));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Read 16-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint16_t datum read from 2 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline uint16_t
bf_ref_u16l(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_swap16(bf_ref_u16n(ptr));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_ref_u16n(ptr);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Read 24-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint32_t datum read from 3 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint32_t
bf_ref_u24l(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_swap24(bf_ref_u24n(ptr));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_ref_u24n(ptr);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 32-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint32_t datum read from 4 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline uint32_t
bf_ref_u32l(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_swap32(bf_ref_u32n(ptr));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_ref_u32n(ptr);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Read 40-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 5 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint64_t
bf_ref_u40l(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_swap40(bf_ref_u40n(ptr));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_ref_u40n(ptr);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 48-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 6 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint64_t
bf_ref_u48l(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_swap48(bf_ref_u48n(ptr));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_ref_u48n(ptr);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 56-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 7 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline uint64_t
bf_ref_u56l(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_swap56(bf_ref_u56n(ptr));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_ref_u56n(ptr);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 64-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A uint64_t datum read from 8 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline uint64_t
bf_ref_u64l(const void *ptr)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_swap64(bf_ref_u64n(ptr));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_ref_u64n(ptr);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Read 16-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int16_t datum read from 2 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline int16_t
bf_ref_s16n(const void *ptr)
{
    const union bf_convert16 data = { .u16 = bf_ref_u16n(ptr) };
    return data.s16;
}

/**
 * Read 24-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int32_t datum read from 3 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int32_t
bf_ref_s24n(const void *ptr)
{
    union bf_convert32 data = { .u32 = bf_ref_u24n(ptr) };
    if (BIT_ISSET(data.u32, BITL(23))) {
        data.u32 |= BITL_ONES(8, 24);
    }
    return data.s32;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 32-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int32_t datum read from 4 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline int32_t
bf_ref_s32n(const void *ptr)
{
    const union bf_convert32 data = { .u32 = bf_ref_u32n(ptr) };
    return data.s32;
}

/**
 * Read 40-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 5 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int64_t
bf_ref_s40n(const void *ptr)
{
    union bf_convert64 data = { .u64 = bf_ref_u40n(ptr) };
    if (BIT_ISSET(data.u64, BITLL(39))) {
        data.u64 |= BITLL_ONES(24, 40);
    }
    return data.s64;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 48-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 6 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int64_t
bf_ref_s48n(const void *ptr)
{
    union bf_convert64 data = { .u64 = bf_ref_u48n(ptr) };
    if (BIT_ISSET(data.u64, BITLL(47))) {
        data.u64 |= BITLL_ONES(16, 48);
    }
    return data.s64;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 56-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 7 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int64_t
bf_ref_s56n(const void *ptr)
{
    union bf_convert64 data = { .u64 = bf_ref_u56n(ptr) };
    if (BIT_ISSET(data.u64, BITLL(55))) {
        data.u64 |= BITLL_ONES(8, 56);
    }
    return data.s64;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 64-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 8 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline int64_t
bf_ref_s64n(const void *ptr)
{
    const union bf_convert64 data = { .u64 = bf_ref_u64n(ptr) };
    return data.s64;
}

/**
 * Read 16-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int16_t datum read from 2 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline int16_t
bf_ref_s16l(const void *ptr)
{
    const union bf_convert16 data = { .u16 = bf_ref_u16l(ptr) };
    return data.s16;
}

/**
 * Read 24-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int32_t datum read from 3 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int32_t
bf_ref_s24l(const void *ptr)
{
    union bf_convert32 data = { .u32 = bf_ref_u24l(ptr) };
    if (BIT_ISSET(data.u32, BITL(23))) {
        data.u32 |= BITL_ONES(8, 24);
    }
    return data.s32;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 32-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int32_t datum read from 4 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline int32_t
bf_ref_s32l(const void *ptr)
{
    const union bf_convert32 data = { .u32 = bf_ref_u32l(ptr) };
    return data.s32;
}

/**
 * Read 40-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 5 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int64_t
bf_ref_s40l(const void *ptr)
{
    union bf_convert64 data = { .u64 = bf_ref_u40l(ptr) };
    if (BIT_ISSET(data.u64, BITLL(39))) {
        data.u64 |= BITLL_ONES(24, 40);
    }
    return data.s64;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 48-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 6 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int64_t
bf_ref_s48l(const void *ptr)
{
    union bf_convert64 data = { .u64 = bf_ref_u48l(ptr) };
    if (BIT_ISSET(data.u64, BITLL(47))) {
        data.u64 |= BITLL_ONES(16, 48);
    }
    return data.s64;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 56-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 7 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int64_t
bf_ref_s56l(const void *ptr)
{
    union bf_convert64 data = { .u64 = bf_ref_u56l(ptr) };
    if (BIT_ISSET(data.u64, BITLL(55))) {
        data.u64 |= BITLL_ONES(8, 56);
    }
    return data.s64;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 64-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 8 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline int64_t
bf_ref_s64l(const void *ptr)
{
    const union bf_convert64 data = { .u64 = bf_ref_u64l(ptr) };
    return data.s64;
}

/**
 * Read 16-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int16_t datum read from 2 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
static inline int16_t
bf_ref_s16b(const void *ptr)
{
    const union bf_convert16 data = { .u16 = bf_ref_u16b(ptr) };
    return data.s16;
}

/**
 * Read 24-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int32_t datum read from 3 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int32_t
bf_ref_s24b(const void *ptr)
{
    union bf_convert32 data = { .u32 = bf_ref_u24b(ptr) };
    if (BIT_ISSET(data.u32, BITL(23))) {
        data.u32 |= BITL_ONES(8, 24);
    }
    return data.s32;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 32-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int32_t datum read from 4 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
static inline int32_t
bf_ref_s32b(const void *ptr)
{
    const union bf_convert32 data = { .u32 = bf_ref_u32b(ptr) };
    return data.s32;
}

/**
 * Read 40-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 5 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int64_t
bf_ref_s40b(const void *ptr)
{
    union bf_convert64 data = { .u64 = bf_ref_u40b(ptr) };
    if (BIT_ISSET(data.u64, BITLL(39))) {
        data.u64 |= BITLL_ONES(24, 40);
    }
    return data.s64;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 48-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 6 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int64_t
bf_ref_s48b(const void *ptr)
{
    union bf_convert64 data = { .u64 = bf_ref_u48b(ptr) };
    if (BIT_ISSET(data.u64, BITLL(47))) {
        data.u64 |= BITLL_ONES(16, 48);
    }
    return data.s64;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 56-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 7 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline int64_t
bf_ref_s56b(const void *ptr)
{
    union bf_convert64 data = { .u64 = bf_ref_u56b(ptr) };
    if (BIT_ISSET(data.u64, BITLL(55))) {
        data.u64 |= BITLL_ONES(8, 56);
    }
    return data.s64;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Read 64-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A int64_t datum read from 8 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
static inline int64_t
bf_ref_s64b(const void *ptr)
{
    const union bf_convert64 data = { .u64 = bf_ref_u64b(ptr) };
    return data.s64;
}

/**
 * Read 32-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A float datum read from 4 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline float
bf_ref_f32n(const void *ptr)
{
    const union bf_convert32 data = { .u32 = bf_ref_u32n(ptr) };
    return data.f32;
}

/**
 * Read 32-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A float datum read from 4 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline float
bf_ref_f32l(const void *ptr)
{
    const union bf_convert32 data = { .u32 = bf_ref_u32l(ptr) };
    return data.f32;
}

/**
 * Read 32-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A float datum read from 4 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
static inline float
bf_ref_f32b(const void *ptr)
{
    const union bf_convert32 data = { .u32 = bf_ref_u32b(ptr) };
    return data.f32;
}

/**
 * Read 64-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A double datum read from 8 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline double
bf_ref_f64n(const void *ptr)
{
    const union bf_convert64 data = { .u64 = bf_ref_u64n(ptr) };
    return data.f64;
}

/**
 * Read 64-bit value from memory in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A double datum read from 8 octets from memory pointed to by
 *         ptr in little endian octet order.
 * @sideeffects None.
 */
static inline double
bf_ref_f64l(const void *ptr)
{
    const union bf_convert64 data = { .u64 = bf_ref_u64l(ptr) };
    return data.f64;
}

/**
 * Read 64-bit value from memory in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A double datum read from 8 octets from memory pointed to by
 *         ptr in big endian octet order.
 * @sideeffects None.
 */
static inline double
bf_ref_f64b(const void *ptr)
{
    const union bf_convert64 data = { .u64 = bf_ref_u64b(ptr) };
    return data.f64;
}

/**
 * Store 16-bit value into a buffer in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_u16n(void *ptr, const uint16_t value)
{
    const unsigned char *src = (const unsigned char*)&value;
    unsigned char *dst = ptr;
#if UFW_BITS_PER_BYTE == 8
    dst[0u] = src[0u];
    dst[1u] = src[1u];
#endif /* UFW_BITS_PER_BYTE == 8 */
#if UFW_BITS_PER_BYTE == 16
    dst[0u] = src[0u];
#endif /* UFW_BITS_PER_BYTE == 16 */
    return dst + sizeof(value);
}

/**
 * Store 24-bit value into a buffer in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u24()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u24n(void *ptr, const uint32_t value)
{
    const unsigned char *src = (const unsigned char*)&value;
    unsigned char *dst = ptr;
#if defined(SYSTEM_ENDIANNESS_BIG)
    dst[0u] = src[1u];
    dst[1u] = src[2u];
    dst[2u] = src[3u];
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
    return dst + 3u;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 32-bit value into a buffer in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_u32n(void *ptr, const uint32_t value)
{
    const unsigned char *src = (const unsigned char*)&value;
    unsigned char *dst = ptr;
#if UFW_BITS_PER_BYTE == 8
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
#endif /* UFW_BITS_PER_BYTE == 8 */
#if UFW_BITS_PER_BYTE == 16
    dst[0u] = src[0u];
    dst[1u] = src[1u];
#endif /* UFW_BITS_PER_BYTE == 16 */
    return dst + sizeof(value);
}

/**
 * Store 40-bit value into a buffer in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u40()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u40n(void *ptr, const uint64_t value)
{
    const unsigned char *src = (const unsigned char*)&value;
    unsigned char *dst = ptr;
#if defined(SYSTEM_ENDIANNESS_BIG)
    dst[0u] = src[3u];
    dst[1u] = src[4u];
    dst[2u] = src[5u];
    dst[3u] = src[6u];
    dst[4u] = src[7u];
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
    dst[4u] = src[4u];
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
    return dst + 5u;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 48-bit value into a buffer in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u48()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u48n(void *ptr, const uint64_t value)
{
    const unsigned char *src = (const unsigned char*)&value;
    unsigned char *dst = ptr;
#if defined(SYSTEM_ENDIANNESS_BIG)
    dst[0u] = src[2u];
    dst[1u] = src[3u];
    dst[2u] = src[4u];
    dst[3u] = src[5u];
    dst[4u] = src[6u];
    dst[5u] = src[7u];
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
    dst[4u] = src[4u];
    dst[5u] = src[5u];
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
    return dst + 6u;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 56-bit value into a buffer in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u56()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u56n(void *ptr, const uint64_t value)
{
    const unsigned char *src = (const unsigned char*)&value;
    unsigned char *dst = ptr;
#if defined(SYSTEM_ENDIANNESS_BIG)
    dst[0u] = src[1u];
    dst[1u] = src[2u];
    dst[2u] = src[3u];
    dst[3u] = src[4u];
    dst[4u] = src[5u];
    dst[5u] = src[6u];
    dst[6u] = src[7u];
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
    dst[4u] = src[4u];
    dst[5u] = src[5u];
    dst[6u] = src[6u];
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
    return dst + 7u;
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 64-bit value into a buffer in native octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_u64n(void *ptr, const uint64_t value)
{
    const unsigned char *src = (const unsigned char*)&value;
    unsigned char *dst = ptr;
#if UFW_BITS_PER_BYTE == 8
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
    dst[4u] = src[4u];
    dst[5u] = src[5u];
    dst[6u] = src[6u];
    dst[7u] = src[7u];
#endif /* UFW_BITS_PER_BYTE == 8 */
#if UFW_BITS_PER_BYTE == 16
    dst[0u] = src[0u];
    dst[1u] = src[1u];
    dst[2u] = src[2u];
    dst[3u] = src[3u];
#endif /* UFW_BITS_PER_BYTE == 16 */
    return dst + sizeof(value);
}

/**
 * Store 16-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_u16b(void *ptr, const uint16_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u16n(ptr, value);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u16n(ptr, bf_swap16(value));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Store 24-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u24()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u24b(void *ptr, const uint32_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u24n(ptr, value);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u24n(ptr, bf_swap24(value));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 32-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_u32b(void *ptr, const uint32_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u32n(ptr, value);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u32n(ptr, bf_swap32(value));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Store 40-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u40()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u40b(void *ptr, const uint64_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u40n(ptr, value);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u40n(ptr, bf_swap40(value));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 48-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u48()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u48b(void *ptr, const uint64_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u48n(ptr, value);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u48n(ptr, bf_swap48(value));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 56-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u56()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u56b(void *ptr, const uint64_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u56n(ptr, value);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u56n(ptr, bf_swap56(value));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 64-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_u64b(void *ptr, const uint64_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u64n(ptr, value);
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u64n(ptr, bf_swap64(value));
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Store 16-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_u16l(void *ptr, const uint16_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u16n(ptr, bf_swap16(value));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u16n(ptr, value);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Store 24-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u24()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u24l(void *ptr, const uint32_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u24n(ptr, bf_swap24(value));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u24n(ptr, value);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 32-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_u32l(void *ptr, const uint32_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u32n(ptr, bf_swap32(value));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u32n(ptr, value);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Store 40-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u40()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u40l(void *ptr, const uint64_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u40n(ptr, bf_swap40(value));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u40n(ptr, value);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 48-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u48()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u48l(void *ptr, const uint64_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u48n(ptr, bf_swap48(value));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u48n(ptr, value);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 56-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u56()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_u56l(void *ptr, const uint64_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u56n(ptr, bf_swap56(value));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u56n(ptr, value);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 64-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_u64l(void *ptr, const uint64_t value)
{
#if defined(SYSTEM_ENDIANNESS_BIG)
    return bf_set_u64n(ptr, bf_swap64(value));
#elif defined(SYSTEM_ENDIANNESS_LITTLE)
    return bf_set_u64n(ptr, value);
#else
    /* Top of file makes sure this can't happen. */
#endif /* SYSTEM_ENDIANNESS_* */
}

/**
 * Store 16-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_s16n(void *ptr, const int16_t value)
{
    const union bf_convert16 data = { .s16 = value };
    return bf_set_u16n(ptr, data.u16);
}

/**
 * Store 24-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u24()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s24n(void *ptr, const int32_t value)
{
    const union bf_convert32 data = { .s32 = value };
    return bf_set_u24n(ptr, data.u32);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 32-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_s32n(void *ptr, const int32_t value)
{
    const union bf_convert32 data = { .s32 = value };
    return bf_set_u32n(ptr, data.u32);
}

/**
 * Store 40-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u40()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s40n(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u40n(ptr, data.u64);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 48-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u48()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s48n(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u48n(ptr, data.u64);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 56-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u56()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s56n(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u56n(ptr, data.u64);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 64-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_s64n(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u64n(ptr, data.u64);
}

/**
 * Store 16-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_s16l(void *ptr, const int16_t value)
{
    const union bf_convert16 data = { .s16 = value };
    return bf_set_u16l(ptr, data.u16);
}

/**
 * Store 24-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u24()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s24l(void *ptr, const int32_t value)
{
    const union bf_convert32 data = { .s32 = value };
    return bf_set_u24l(ptr, data.u32);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 32-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_s32l(void *ptr, const int32_t value)
{
    const union bf_convert32 data = { .s32 = value };
    return bf_set_u32l(ptr, data.u32);
}

/**
 * Store 40-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u40()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s40l(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u40l(ptr, data.u64);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 48-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u48()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s48l(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u48l(ptr, data.u64);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 56-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u56()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s56l(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u56l(ptr, data.u64);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 64-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_s64l(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u64l(ptr, data.u64);
}

/**
 * Store 16-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 2 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_s16b(void *ptr, const int16_t value)
{
    const union bf_convert16 data = { .s16 = value };
    return bf_set_u16b(ptr, data.u16);
}

/**
 * Store 24-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 3 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u24()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s24b(void *ptr, const int32_t value)
{
    const union bf_convert32 data = { .s32 = value };
    return bf_set_u24b(ptr, data.u32);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 32-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_s32b(void *ptr, const int32_t value)
{
    const union bf_convert32 data = { .s32 = value };
    return bf_set_u32b(ptr, data.u32);
}

/**
 * Store 40-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 5 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u40()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s40b(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u40b(ptr, data.u64);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 48-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 6 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u48()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s48b(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u48b(ptr, data.u64);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 56-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 7 octets in size.
 *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_u56()' to
 * perform this test manually if required.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
#if UFW_BITS_PER_BYTE == 8
static inline void*
bf_set_s56b(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u56b(ptr, data.u64);
}
#endif /* UFW_BITS_PER_BYTE == 8 */

/**
 * Store 64-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_s64b(void *ptr, const int64_t value)
{
    const union bf_convert64 data = { .s64 = value };
    return bf_set_u64b(ptr, data.u64);
}

/**
 * Store 32-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_f32n(void *ptr, const float value)
{
    const union bf_convert32 data = { .f32 = value };
    return bf_set_u32n(ptr, data.u32);
}

/**
 * Store 32-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_f32l(void *ptr, const float value)
{
    const union bf_convert32 data = { .f32 = value };
    return bf_set_u32l(ptr, data.u32);
}

/**
 * Store 32-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 4 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_f32b(void *ptr, const float value)
{
    const union bf_convert32 data = { .f32 = value };
    return bf_set_u32b(ptr, data.u32);
}

/**
 * Store 64-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_f64n(void *ptr, const double value)
{
    const union bf_convert64 data = { .f64 = value };
    return bf_set_u64n(ptr, data.u64);
}

/**
 * Store 64-bit value into a buffer in little endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_f64l(void *ptr, const double value)
{
    const union bf_convert64 data = { .f64 = value };
    return bf_set_u64l(ptr, data.u64);
}

/**
 * Store 64-bit value into a buffer in big endian octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * 8 octets in size.
 *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
static inline void*
bf_set_f64b(void *ptr, const double value)
{
    const union bf_convert64 data = { .f64 = value };
    return bf_set_u64b(ptr, data.u64);
}

#if UFW_BITS_PER_BYTE == 8

/**
 * Test if value is a valid 24-bit unsigned integer
 *
 * @param  value   uint32_t datum to perform range test on.
 *
 * @return True if value is within valid range; false otherwise.
 * @sideeffects None.
 */
static inline bool
bf_inrange_u24(const uint32_t value)
{
    return (value < (1ul << 24u));
}

/**
 * Test if value is a valid 24-bit signed integer
 *
 * @param  value   int32_t datum to perform range test on.
 *
 * @return True if value is within valid range; false otherwise.
 * @sideeffects None.
 */
static inline bool
bf_inrange_s24(const int32_t value)
{
    const int32_t a = (1ul << 23u);
    return ((value >= (-1 * a)) && (value < a));
}

/**
 * Test if value is a valid 40-bit unsigned integer
 *
 * @param  value   uint64_t datum to perform range test on.
 *
 * @return True if value is within valid range; false otherwise.
 * @sideeffects None.
 */
static inline bool
bf_inrange_u40(const uint64_t value)
{
    return (value < (1ull << 40u));
}

/**
 * Test if value is a valid 40-bit signed integer
 *
 * @param  value   int64_t datum to perform range test on.
 *
 * @return True if value is within valid range; false otherwise.
 * @sideeffects None.
 */
static inline bool
bf_inrange_s40(const int64_t value)
{
    const int64_t a = (1ull << 39u);
    return ((value >= (-1 * a)) && (value < a));
}

/**
 * Test if value is a valid 48-bit unsigned integer
 *
 * @param  value   uint64_t datum to perform range test on.
 *
 * @return True if value is within valid range; false otherwise.
 * @sideeffects None.
 */
static inline bool
bf_inrange_u48(const uint64_t value)
{
    return (value < (1ull << 48u));
}

/**
 * Test if value is a valid 48-bit signed integer
 *
 * @param  value   int64_t datum to perform range test on.
 *
 * @return True if value is within valid range; false otherwise.
 * @sideeffects None.
 */
static inline bool
bf_inrange_s48(const int64_t value)
{
    const int64_t a = (1ull << 47u);
    return ((value >= (-1 * a)) && (value < a));
}

/**
 * Test if value is a valid 56-bit unsigned integer
 *
 * @param  value   uint64_t datum to perform range test on.
 *
 * @return True if value is within valid range; false otherwise.
 * @sideeffects None.
 */
static inline bool
bf_inrange_u56(const uint64_t value)
{
    return (value < (1ull << 56u));
}

/**
 * Test if value is a valid 56-bit signed integer
 *
 * @param  value   int64_t datum to perform range test on.
 *
 * @return True if value is within valid range; false otherwise.
 * @sideeffects None.
 */
static inline bool
bf_inrange_s56(const int64_t value)
{
    const int64_t a = (1ull << 55u);
    return ((value >= (-1 * a)) && (value < a));
}

#endif /* UFW_BITS_PER_BYTE == 8 */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* INC_UFW_BINARY_FORMAT_H */
