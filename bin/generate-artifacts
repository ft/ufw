#!/bin/sh

FIRMWARE_NAME=no-name
FIRMWARE_MCU=unknown
FIRMWARE_TYPE=generic
BUILD_VARIANT=default
BUILD_PROFILE=unknown

MAJOR_VERSION=0
MINOR_VERSION=0
PATCHLEVEL=0

is_opt () {
    case "$1" in
    -*) return 0 ;;
    *) return 1 ;;
    esac
}

while is_opt "$1"; do
    opt="$1"
    value="$2"
    shift 2
    case "$opt" in
    -n) FIRMWARE_NAME="$value" ;;
    -m) FIRMWARE_MCU="$value"  ;;
    -t) FIRMWARE_TYPE="$value" ;;
    -b) BUILD_VARIANT="$value" ;;
    -p) BUILD_PROFILE="$value" ;;
    *) printf 'Unknown option: %s\n' "$opt"
       exit 1
       ;;
    esac
done

base="$1"
output="$2"
extensions="$3"

if test "x$base" = x || test "x$output" = x || test "x$extensions" = x; then
    printf 'usage: generate-artifacts <BASENAME> <DESTINATION> <EXTENSION[s...]>' >&2
    printf ' [-- FILES-TO-SOURCE...]\n' >&2
    exit 1
fi

shift 3

while test "$#" -gt 0 && test "x$1" != x--; do
    extensions="${extensions} $1"
    shift
done

if test "x$1" = x--; then
    shift
    for file in "$@"; do
        case "$file" in
        */*) ;;
        *) file="./$file"
        esac
        . "$file"
    done
fi

if test "x$HARDWARE_TYPE" != x; then
    # Backward compatibility
    FIRMWARE_NAME="$HARDWARE_TYPE"
fi
# This is the prefix used (in connection with a version tag from the *_VERSION
# definitions above) to produce the final MCU firmware filenames.
BITSTREAM_PREFIX="${FIRMWARE_NAME}"
if test "$FIRMWARE_MCU" != unknown; then
    BITSTREAM_PREFIX="${BITSTREAM_PREFIX}_${FIRMWARE_MCU}"
fi
if test "$FIRMWARE_TYPE" != generic; then
    BITSTREAM_PREFIX="${BITSTREAM_PREFIX}_${FIRMWARE_TYPE}"
fi
if test "$BUILD_VARIANT" != default; then
    BITSTREAM_PREFIX="${BITSTREAM_PREFIX}_${BUILD_VARIANT}"
fi

if type git_populate > /dev/null 2>&1; then
    # User supplied git.sh in FILES-TO-SOURCE.
    git_populate
    git_got_info && git_amend_versions
else
    printf 'version.h: Git integration not loaded.' >&2
    printf ' Lots of information will be blank!\n' >&2
    git_got_info () { return 1; }
fi

if git_got_info; then
    DESTINATION="${BITSTREAM_PREFIX}"
    if git_exact_version; then
        DESTINATION="${DESTINATION}_v${__GIT_VERSION__}"
    else
        if test "x${__GIT_BRANCH__}${GITINT_IGNORE_DETACHED_HEAD}" = "xDetachedHead1"; then
            DESTINATION="${DESTINATION}_v${__GIT_VERSION__}"
        else
            DESTINATION="${DESTINATION}_${__GIT_BRANCH__}_v${__GIT_VERSION__}"
        fi
    fi
else
    DESTINATION="${BITSTREAM_PREFIX}_v$MAJOR_VERSION"
    DESTINATION="${DESTINATION}.$MINOR_VERSION"
    DESTINATION="${DESTINATION}.${PATCHLEVEL}"
    # We may have dirty-information, though:
    if git_dirty; then
        DESTINATION="${DESTINATION}-dirty"
    fi
fi

if test "$BUILD_PROFILE" != unknown; then
    DESTINATION="${DESTINATION}_${BUILD_PROFILE}"
fi

if test "$output" != '.'; then
    DESTINATION="${output}/${DESTINATION}"
fi

if test "x$extensions" = "x++"; then
    printf '%s\n' "$DESTINATION"
    exit 0
fi

printf 'Producing versioned variants:\n'
for ext in $extensions; do
    printf '    file: %s\n' "$DESTINATION.$ext"
    cp "${base}.$ext" "$DESTINATION.$ext"
    chmod 0644 "$DESTINATION.$ext"
done
