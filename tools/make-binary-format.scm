;; Copyright (c) 2023-2025 ufw workers, All rights reserved.
;;
;; Terms for redistribution and use can be found in LICENCE.

;; Generate binary-format API.
;;
;; This code is pretty repetitive, and typing it out by hand is error prone.

(use-modules (ice-9 format)
             (ice-9 match)
             (rnrs bytevectors)
             (srfi srfi-1)
             (srfi srfi-19)
             (srfi srfi-42))

(define (c-inclusion-guard-start)
  (format #t "#ifndef INC_UFW_BINARY_FORMAT_H
#define INC_UFW_BINARY_FORMAT_H

"))

(define (open-extern-c)
  (format #t "
#ifdef __cplusplus
extern \"C\" {
#endif /* __cplusplus */
"))

(define (close-extern-c)
  (format #t "
#ifdef __cplusplus
}
#endif /* __cplusplus */
"))

(define (c-inclusion-guard-end)
  (format #t "
#endif /* INC_UFW_BINARY_FORMAT_H */
"))

(define (c-include-system sym)
  (format #t "#include <~a.h>~%" sym))

(define (c-include-ufw sym)
  (format #t "#include <ufw/~a.h>~%" sym))

(define (make-copyright)
  (let ((start-year 2019))
    (format #t "/*
 * Copyright (c) ~d-~d ufw workers, All rights reserved.
 *
 * Terms for redistribution and use can be found in LICENCE.
 *
 * This file is generated by ‘tools/make-binary-format.scm’.
 */
"
            start-year (date-year (current-date)))))

(define (make-file-doc)
  (format #t
          "/**
 * @addtogroup binformat Binary Format Conversion
 *
 * Read and write access to binary memory with type semantics
 *
 * The `ufw/binary-format.h` header file implements ways to access arbitrary
 * binary data with a number of integer and floating point semantics. The
 * accesses can be reading as well as writing. The API follows a mnemonic
 * naming scheme. The header defines all its functions as `static inline` to
 * minimise calling overhead. The documentation of `ufw/binary-format.h` for
 * the full description and API.
 *
 * @{
 */

/**
 * @file binary-format.h
 * @brief Binary format conversion API
 *
 * This module implements a number of functions that revolve around reading and
 * writing values to/from raw memory. This is done in three octet-orders
 * (endianness): Native, big and little; where native endianness is one of the
 * other two.
 *
 * The API follows a naming scheme:
 *
 *     bf_[OPERATION]_[TYPEMNEMONIC][WIDTH][ORDER](...)
 *
 * Where OPERATION is either `ref` or `set`. The `ref` (reference) operation
 * extracts a datum from raw memory; and the `set` operation transfers a datum
 * into raw memory.
 *
 * Where TYPEMNEMONIC is either `u` or `s` or `f` for unsigned integers, signed
 * integers and floating point values respectively; and
 *
 * Where WIDTH is a width designation in bits. Integer operations support 16,
 * 32 and 64 bits; on machines where a byte is an octet, integer operations also
 * support 24, 40, 48 and 56 bit word widths. Floating point values support 32
 * and 64 bits.
 *
 * Where ORDER is either `n` or `b` or `l` for native, big or little endianness
 * respectively.
 *
 * To put a 32-bit floating point value into memory, in big-endian octet order:
 *
 * @code
 *     uint8_t memory[128];
 *     // ...
 *     bf_set_f32b(memory, 123.f);
 * @endcode
 *
 * Similarly, to reference a 32-bit floating point value in memory, in big 
 * endian octet order:
 *
 * @code
 *     float foo = bf_ref_f32b(memory);
 * @endcode
 *
 * In addition to these `ref` and `set` operations, the module also implements
 * simple range-check functions, on systems that support the 24, 40, 48 and 56
 * bit wide operations. When putting a datum into raw memory, no range checks
 * are performed implicitly. If data such validation is required, use one of
 * the functions that follow this API scheme:
 *
 *     bool bf_inrange_[TYPEMNEMONIC][WIDTH](const TYPE value);
 *
 * These functions return a boolean value indicating whether or not the provided
 * value is valid for the indicated type and word width. The TYPEMNEMONIC part
 * is either `u` for unsigned integers or `s` for signed integers. The WIDTH
 * part is one of the aforementioned word widths.
 *
 * For example, to test if a value is a signed 40 bit integer use:
 *
 * @code
 *     if (bf_inrange_s40(-12345)) {
 *         bf_set_s40b(memory, -12345);
 *     }
 * @endcode
 *
 * Portability notes:
 *
 * The module supports (and was tested with) little and big endian machines.
 *
 * The size of a byte is the smallest addressable word in memory on a given
 * machine. In particular, the colloquially used notion of a byte being eight
 * bits of memory, is not correct in general. A more precise name for eight
 * bits of memory is an octet. The POSIX specification requires a byte to be
 * an octet, but the C language notably does not. This module supports systems
 * that use 8 bit and 16 bit bytes (other byte sizes are not supported and
 * will cause a build-failure). However, the parts of the API that support
 * partial word-sizes (24, 40, 48, and 56) are only supported on 8-bit
 * addressable machines.
 *
 * Integer encoding across architectures is pretty portable these days. Two's
 * complement is used universally in all modern architectures. There are things
 * like IBM main frames that use BCD for example, and there will be other
 * examples, that could be brought up here. If your system does not use two's
 * complement, signed-integer semantics will not work as intended.
 *
 * Floating point number encodings are less portable, but IEEE754 is pretty
 * common. This module implements all accesses on the architecture's native
 * representation. If your system does not use IEEE754 floating point
 * encoding, floating point semantics will not work as intended.
 */

/**
 * @}
 */
"))

(define (make-c++-warning:type-punning)
  (format #t "#ifdef __cplusplus
#ifndef CXX_ALLOW_TYPE_PUNNING
#warning \"binary-format uses type punning, which is undefined behaviour in C++!\"
#warning \"Your toolchain may allow it as an extension, but be advised!\"
#warning \"To disable this warning, define the CXX_ALLOW_TYPE_PUNNING macro.\"
#endif /* CXX_ALLOW_TYPE_PUNNING */
#endif /* __cplusplus */
"))

(define (make-ensure-octet-order)
  (format #t "#if !(defined(SYSTEM_ENDIANNESS_BIG)) && !(defined(SYSTEM_ENDIANNESS_LITTLE))
#error \"System octet-order is not indicated! Cannot use binary-format.h for that reason!\"
#endif /* !(defined(SYSTEM_ENDIANNESS_*)) */
"))

(define (make-ensure-byte-size)
  (format #t "#if !(UFW_BITS_PER_BYTE == 8 || UFW_BITS_PER_BYTE == 16)
#error \"System byte-size is unsupported! Cannot use binary-format.h for that reason!\"
#endif /* Unsupported Byte Size */
"))

(define (make-conversion-unions)
  (display "
union bf_convert16 {
    uint16_t u16;
    int16_t s16;
};

union bf_convert32 {
    uint32_t u32;
    int32_t s32;
    float f32;
};

union bf_convert64 {
    uint64_t u64;
    int64_t s64;
    double f64;
};
"))

(define *bits-per-nibble* 4)
(define *bits-per-octet* (* 2 *bits-per-nibble*))
(define *all-bits-octet* (1- (ash 1 *bits-per-octet*)))
(define *powers-of-two* (list-ec (: i 4 7) (ash 1 i)))
(define *word-sizes* (list-ec (: i
                                 (first *powers-of-two*)
                                 (1+ (last *powers-of-two*))
                                 *bits-per-octet*)
                              i))

(define *indent* (make-string 4 #\space))
(define *return-expr* (string-concatenate (list *indent* "return ( ")))
(define *or-expr* (string-concatenate
                   (list (make-string 1 #\newline)
                         (make-string (- (string-length *return-expr*) 2)
                                      #\space)
                         "| ")))
(define *end-expr* ");")

(define (literal-suffix n)
  (cond ((> n 32) 'ull)
        ((> n 16) 'ul)
        (else 'u)))

(define (next-power-of-2 n)
  (let loop ((k 16))
    (if (>= k n) k (loop (ash k 1)))))

(define (bits->digits n)
  "Calculate number of hex digits for a given number of bits.

Example: (bits->digits 16) → 4"
  (inexact->exact (ceiling (/ n *bits-per-nibble*))))

(define (max-integer-width lst)
  "Calculate number of digits for the largest integer in a list.

Examples:
  (max-integer-width '(1 2 9))   → 1
  (max-integer-width '(1 2 10))  → 2
  (max-integer-width '(1 2 100)) → 3"
  (inexact->exact (ceiling (log10 (+ 1 (apply max lst))))))

(define (make-mask-and-shifter sym bits shift-align suffix)
  "Return a function that generates a sub-expression in a swap expression.

A sub-expression looks like this ((value & mask) OPERATOR shift).

The tabular alignment is handed in as arguments to the generator function."
  (lambda (mask op shift)
    (if (zero? shift)
        (format #f "((~a & 0x~v,'0x~a))" sym (bits->digits bits) mask suffix)
        (format #f "((~a & 0x~v,'0x~a) ~a ~vdu)"
                sym (bits->digits bits) mask suffix op shift-align shift))))

(define (make-swap-down-shifts n)
  "Generate a list of down shifts required for a swap expression."
  (list-ec (: i (- n *bits-per-octet*) 0 (* -2 *bits-per-octet*)) i))

(define (make-swap-masks n)
  "Generate a list of bits-mask for a given word-width"
  (list-ec (:do ((i (* *all-bits-octet*
                       (ash 1 (- n *bits-per-octet*)))))
                (> i 0)
                ((ash i (* -1 *bits-per-octet*))))
           i))

(define (make-swap-args n)
  "Generate a list of arguments for mask-and-shifter function for word width n"
  (let* ((down* (make-swap-down-shifts n))
         (down (map (lambda (x) (list '>> x)) down*))
         (mid (if (odd? (/ n *bits-per-octet*))
                  '((<< 0))
                  '()))
         (up (map (lambda (x) (list '<< x)) (reverse down*))))
    (map (lambda (mask x) (cons mask x))
         (make-swap-masks n)
         (concatenate (list down mid up)))))

(define (maybe-builtin-swap n)
  (format #t "#if defined(HAVE_COMPILER_BUILTIN_BSWAP~d) && defined(UFW_USE_BUILTIN_SWAP)
    return __builtin_bswap~d(value);
#else
" n n))

(define (end-builtin-swap n)
  (format #t "#endif /* HAVE_COMPILER_BUILTIN_BSWAP~d */~%" n))

(define (bvref n bv endianness)
  (unless (zero? (modulo n *bits-per-octet*))
    (throw 'invalid-word-width n))
  (bytevector-uint-ref bv 0 endianness (/ n *bits-per-octet*)))

(define (make-swap-apidoc n)
  (let ((example #vu8(#x12 #x34 #x56 #x78 #x90 #xab #xcd #xef))
        (digits (bits->digits n)))
    (format #t "/**
 * Byte-swap ~d bit value
 *
 * Turn `0x~v,'0x` into `0x~v,'0x`.
 *
 * @param  value   The value to transform
 *
 * @return The byte-swapped value.
 * @sideeffects None.
 */~%"
            n
            digits (bvref n example 'big)
            digits (bvref n example 'little))))

(define (make-swap-octets n)
  "Generate an octet swapping function for word width n."
  (let* ((typewidth (next-power-of-2 n))
         (precise? (= typewidth n)))
    (newline)
    (make-swap-apidoc n)
    (format #t "static inline uint~d_t~%bf_swap~d(const uint~d_t value)~%{~%"
            typewidth n typewidth)
    (when precise? (maybe-builtin-swap n))
    (display *return-expr*)
    (let ((shift-align (max-integer-width (make-swap-down-shifts n))))
      (display
       (string-join (map (lambda (args)
                           (apply (make-mask-and-shifter 'value
                                                         n
                                                         shift-align
                                                         (literal-suffix n))
                                  args))
                         (make-swap-args n))
                    *or-expr*)))
    (display *end-expr*)
    (newline)
    (when precise? (end-builtin-swap n))
    (format #t "}~%")))

(define (make-word-copy-expression dst src)
  (lambda* (idx doffset soffset)
    (format #f "~a[~du] = ~a[~du];" dst (+ doffset idx) src (+ soffset idx))))

(define (indent)
  (display "    "))

(define steps '(8 16))

(define (make-reference-prototype width typewidth type endianness)
  (format #t "static inline uint~d_t~%bf_ref_~a~d~a(const void *ptr)~%{~%"
          typewidth type width endianness))

(define (make-reference/apidoc width type order)
  (let ((octets (/ width *bits-per-octet*)))
    (format #t "
/**
 * Read ~d-bit value from memory in ~a octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * ~d octets in size.
 *
 * @param  ptr    Pointer to memory from which to read data.
 *
 * @return A ~a datum read from ~d octets from memory pointed to by
 *         ptr in ~a octet order.
 * @sideeffects None.
 */
"
            width order octets type octets order)))
(define (make-set!/apidoc width type order)
  (define (is-signed-type? type)
    (member type '(uint16_t uint32_t uint64_t)))
  (let ((octets (/ width *bits-per-octet*))
        (precise? (= width (next-power-of-2 width))))
    (format #t "
/**
 * Store ~d-bit value into a buffer in ~a octet order
 *
 * The buffer pointed to must be large enough to store a datum that is
 * ~d octets in size.
"
            width order octets)
    (unless precise?
      (format #t " *
 * Note that this function's argument is able to store values that are
 * beyond the indicated word width, and the function does not check if
 * the value fits into the valid range. Use `bf_inrange_~a~d()' to
 * perform this test manually if required.
"
              (if (is-signed-type? type) 's 'u) width))
(format #t " *
 * @param  ptr    Pointer to memory in which to store data.
 * @param  value  Value to store into memory
 *
 * @return Pointer to memory on the first byte after the newly stored
 *         value.
 * @sideeffects None.
 */
")))

(define (make-reference-native width)
  (let* ((typewidth (next-power-of-2 width))
         (precise? (= typewidth width)))
    (make-reference/apidoc width (format #f "uint~d_t" typewidth) "native")
    (unless precise?
      (format #t "#if UFW_BITS_PER_BYTE == 8~%"))
    (make-reference-prototype width typewidth 'u 'n)
    (indent)
    (format #t "uint~d_t buffer = 0~a;~%" typewidth (literal-suffix width))
    (indent)
    (format #t "const unsigned char *src = ptr;~%")
    (indent)
    (format #t "unsigned char *dst = (unsigned char*)&buffer;~%")

    (for-each (lambda (step)
                (when precise?
                  (format #t "#if UFW_BITS_PER_BYTE == ~d~%" step))
                (letrec* ((generate (make-word-copy-expression 'dst 'src))
                          (pexpr (lambda* (idx offset)
                                   (indent)
                                   (display (generate idx offset 0))
                                   (newline)))
                          (pexprs (lambda (n i o)
                                    (when (> n 0)
                                      (pexpr i o)
                                      (pexprs (- n step) (1+ i) o))))
                          (be-offset (/ (- typewidth width) *bits-per-octet*)))
                  (if precise?
                      (pexprs width 0 0)
                      (begin
                        (format #t "#if defined(SYSTEM_ENDIANNESS_BIG)~%")
                        (pexprs width 0 be-offset)
                        (format #t "#elif defined(SYSTEM_ENDIANNESS_LITTLE)~%")
                        (pexprs width 0 0)
                        (format #t "#else~%")
                        (indent)
                        (format #t "/* Top of file makes sure this can't happen. */~%")
                        (format #t "#endif /* SYSTEM_ENDIANNESS_* */~%"))))
                (when precise?
                  (format #t "#endif /* UFW_BITS_PER_BYTE == ~d */~%" step)))
              (if precise? steps (list *bits-per-octet*)))

    (indent)
    (format #t "return buffer;~%")
    (format #t "}~%")
    (unless precise?
      (format #t "#endif /* UFW_BITS_PER_BYTE == 8 */~%"))))

(define (make-set!-prototype width typewidth type endianness)
  (format #t "static inline void*~%bf_set_~a~d~a(void *ptr, const uint~d_t value)~%{~%"
          type width endianness typewidth))

(define (make-set!-native width)
  (let* ((typewidth (next-power-of-2 width))
         (precise? (= width typewidth)))
    (make-set!/apidoc width (format #f "uint~d_t" typewidth) "native")
    (unless precise?
      (format #t "#if UFW_BITS_PER_BYTE == 8~%"))
    (make-set!-prototype width typewidth 'u 'n)
    (indent)
    (format #t "const unsigned char *src = (const unsigned char*)&value;~%")
    (indent)
    (format #t "unsigned char *dst = ptr;~%")

    (for-each (lambda (step)
                (when precise?
                  (format #t "#if UFW_BITS_PER_BYTE == ~d~%" step))
                (letrec* ((generate (make-word-copy-expression 'dst 'src))
                          (pexpr (lambda* (idx offset)
                                   (indent)
                                   (display (generate idx 0 offset))
                                   (newline)))
                          (pexprs (lambda (n i o)
                                    (when (> n 0)
                                      (pexpr i o)
                                      (pexprs (- n step) (1+ i) o))))
                          (be-offset (/ (- typewidth width) *bits-per-octet*)))
                  (if precise?
                      (pexprs width 0 0)
                      (begin
                        (format #t "#if defined(SYSTEM_ENDIANNESS_BIG)~%")
                        (pexprs width 0 be-offset)
                        (format #t "#elif defined(SYSTEM_ENDIANNESS_LITTLE)~%")
                        (pexprs width 0 0)
                        (format #t "#else~%")
                        (indent)
                        (format #t "/* Top of file makes sure this can't happen. */~%")
                        (format #t "#endif /* SYSTEM_ENDIANNESS_* */~%"))))
                (when precise?
                  (format #t "#endif /* UFW_BITS_PER_BYTE == ~d */~%" step)))
              (if precise? steps (list *bits-per-octet*)))

    (indent)
    (format #t "return dst + ~a;~%"
            (if precise?
                "sizeof(value)"
                (format #f "~au" (/ width *bits-per-octet*))))
    (format #t "}~%")
    (unless precise?
      (format #t "#endif /* UFW_BITS_PER_BYTE == 8 */~%"))))

(define (make-ref-and-swap width)
  (format #t "return bf_swap~d(bf_ref_u~dn(ptr));~%" width width))

(define (make-ref-return width with-swap?)
  (if with-swap?
      (make-ref-and-swap width)
      (format #t "return bf_ref_u~dn(ptr);~%" width)))

(define (make-reference width big?)
  (let* ((typewidth (next-power-of-2 width))
         (precise? (= typewidth width)))
    (make-reference/apidoc width
                           (format #f "uint~d_t" typewidth)
                           (if big? "big endian" "little endian"))
    (unless precise?
      (format #t "#if UFW_BITS_PER_BYTE == 8~%"))
    (make-reference-prototype width typewidth 'u (if big? 'b 'l))
    (format #t "#if defined(SYSTEM_ENDIANNESS_BIG)~%")
    (indent)
    (make-ref-return width (not big?))
    (format #t "#elif defined(SYSTEM_ENDIANNESS_LITTLE)~%")
    (indent)
    (make-ref-return width big?)
    (format #t "#else~%")
    (indent)
    (format #t "/* Top of file makes sure this can't happen. */~%")
    (format #t "#endif /* SYSTEM_ENDIANNESS_* */~%")
    (format #t "}~%")
    (unless precise?
      (format #t "#endif /* UFW_BITS_PER_BYTE == 8 */~%"))))

(define (make-swap-and-set width)
  (format #t "return bf_set_u~dn(ptr, bf_swap~d(value));~%" width width))

(define (make-set!-return width with-swap?)
  (if with-swap?
      (make-swap-and-set width)
      (format #t "return bf_set_u~dn(ptr, value);~%" width)))

(define (make-set! width big?)
  (let* ((typewidth (next-power-of-2 width))
         (precise? (= typewidth width)))
    (make-set!/apidoc width (format #f "uint~d_t" width)
                      (if big? "big endian" "little endian"))
    (unless precise?
      (format #t "#if UFW_BITS_PER_BYTE == 8~%"))
    (make-set!-prototype width typewidth 'u (if big? 'b 'l))
    (format #t "#if defined(SYSTEM_ENDIANNESS_BIG)~%")
    (indent)
    (make-set!-return width (not big?))
    (format #t "#elif defined(SYSTEM_ENDIANNESS_LITTLE)~%")
    (indent)
    (make-set!-return width big?)
    (format #t "#else~%")
    (indent)
    (format #t "/* Top of file makes sure this can't happen. */~%")
    (format #t "#endif /* SYSTEM_ENDIANNESS_* */~%")
    (format #t "}~%")
    (unless precise?
      (format #t "#endif /* UFW_BITS_PER_BYTE == 8 */~%"))))

(define (make-int-type-namer m)
  (lambda (w)
    (format #f "~a~d_t" m (next-power-of-2 w))))

(define (make-float-type-namer m)
  (lambda (_)
    (symbol->string m)))

(define other-types `(((mnemonics (s . ,(make-int-type-namer 'int)))
                       (widths . ,*word-sizes*))
                      ((mnemonics (f . ,(make-float-type-namer 'float)))
                       (widths 32))
                      ((mnemonics (f . ,(make-float-type-namer 'double)))
                       (widths 64))))

(define (for-typespec fnc typespec)
  (for-each
   (lambda (type)
     (let ((mns (assq-ref type 'mnemonics))
           (widths (assq-ref type 'widths))
           (endians '(n l b)))
       (for-each
        (lambda (endian)
          (for-each
           (lambda (mnemonic)
             (let ((short (car mnemonic))
                   (type-namer (cdr mnemonic)))
               (for-each
                (lambda (width)
                  (fnc endian short (type-namer width) width))
                widths)))
           mns))
        endians)
       ))
   typespec))

(define (make-bit-suffix n)
  (let* ((suffix (literal-suffix n))
         (string (string-upcase (symbol->string suffix))))
    (substring string 1)))

(define (make-other-reference typespec)
  (for-typespec (lambda (endian short type width)
                  (let* ((typewidth (next-power-of-2 width))
                         (precise? (= typewidth width))
                         (with-sign-adjust? (and (not precise?) (eq? short 's)))
                         (bit-suffix (make-bit-suffix typewidth))
                         (const-prefix (if with-sign-adjust? "" "const ")))
                    (make-reference/apidoc width
                                           type
                                           (if (eq? endian 'b)
                                               "big endian"
                                               "little endian"))
                    (unless precise?
                      (format #t "#if UFW_BITS_PER_BYTE == 8~%"))
                    (format #t "static inline ~a
bf_ref_~a~d~a(const void *ptr)
{
    ~aunion bf_convert~d data = { .u~d = bf_ref_u~d~a(ptr) };
"
                            type short width endian
                            const-prefix typewidth typewidth width endian)
                    (when with-sign-adjust?
                      (format #t "    if (BIT_ISSET(data.u~d, BIT~a(~d))) {
        data.u~d |= BIT~a_ONES(~d, ~d);
    }
"
                              typewidth bit-suffix (1- width)
                              typewidth bit-suffix (- typewidth width) width))
                    (format #t "    return data.~a~d;
}
"
                            short typewidth)
                    (unless precise?
                      (format #t "#endif /* UFW_BITS_PER_BYTE == 8 */~%"))))
                typespec))

(define (make-other-set! typespec)
  (for-typespec (lambda (endian short type width)
                  (let* ((typewidth (next-power-of-2 width))
                         (precise? (= width typewidth)))
                    (make-set!/apidoc width
                                      type
                                      (if (eq? endian 'b)
                                          "big endian"
                                          "little endian"))
                    (unless precise?
                      (format #t "#if UFW_BITS_PER_BYTE == 8~%"))
                    (format #t "static inline void*
bf_set_~a~d~a(void *ptr, const ~a value)
{
    const union bf_convert~d data = { .~a~d = value };
    return bf_set_u~d~a(ptr, data.u~d);
}
"
                            short width endian type
                            typewidth short typewidth
                            width endian typewidth)
                    (unless precise?
                      (format #t "#endif /* UFW_BITS_PER_BYTE == 8 */~%"))))
                typespec))

(define (make-range-check/apidoc n signed?)
  (format #t "
/**
 * Test if value is a valid ~d-bit ~asigned integer
 *
 * @param  value   ~aint~d_t datum to perform range test on.
 *
 * @return True if value is within valid range; false otherwise.
 * @sideeffects None.
 */
"
          n (if signed? "" "un")
          (if signed? "" "u") (next-power-of-2 n)))

(define (make-range-check n)
  (let ((typewidth (next-power-of-2 n))
        (m (1- n)))
    (make-range-check/apidoc n #f)
    (format #t "static inline bool
bf_inrange_u~d(const uint~d_t value)
{
    return (value < (1~a << ~du));
}
"
            n typewidth (literal-suffix n) n)
    (make-range-check/apidoc n #t)
    (format #t "static inline bool
bf_inrange_s~d(const int~d_t value)
{
    const int~d_t a = (1~a << ~du);
    return ((value >= (-1 * a)) && (value < a));
}
"
            n typewidth
            typewidth (literal-suffix n) m)))

(make-copyright)
(newline)
(make-file-doc)
(newline)
(c-inclusion-guard-start)
(c-include-system 'stdbool)
(c-include-system 'stdint)
(newline)
(c-include-ufw 'bit-operations)
(c-include-ufw 'toolchain)
(newline)
(make-c++-warning:type-punning)
(newline)
(make-ensure-octet-order)
(newline)
(make-ensure-byte-size)
(open-extern-c)
(make-conversion-unions)
(for-each make-swap-octets *word-sizes*)
(for-each make-reference-native *word-sizes*)
(for-each (lambda (w) (make-reference w #t)) *word-sizes*)
(for-each (lambda (w) (make-reference w #f)) *word-sizes*)
(make-other-reference other-types)
(for-each make-set!-native *word-sizes*)
(for-each (lambda (w) (make-set! w #t)) *word-sizes*)
(for-each (lambda (w) (make-set! w #f)) *word-sizes*)
(make-other-set! other-types)
(format #t "~%#if UFW_BITS_PER_BYTE == 8~%")
(for-each make-range-check (filter (lambda (n) (not (memv n *powers-of-two*)))
                                   *word-sizes*))
(format #t "~%#endif /* UFW_BITS_PER_BYTE == 8 */~%")
(close-extern-c)
(c-inclusion-guard-end)
